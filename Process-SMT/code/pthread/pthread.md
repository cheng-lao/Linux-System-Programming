


## pthread_create函数
这是 Linux 多线程编程的核心函数。通过 `pthread_create`，你可以让程序“分身”，同时执行多个不同的任务。

我们可以把这个函数类比为：**雇佣一个员工（创建线程）并告诉他去干什么。**

---

### 1. 参数详解

```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);

```

#### ① `pthread_t *thread` (员工工号)

* **作用：** 这是一个**传出参数**。函数成功后，会将新线程的 **Thread ID**（即我们之前聊过的那个内存地址）写入这个变量。
* **用途：** 后续如果你想回收（join）或杀死（cancel）这个线程，就需要用到它。

#### ② `const pthread_attr_t *attr` (雇佣合同)

* **作用：** 设置线程的属性（如栈大小、调度优先级、是否分离等）。
* **常用值：** 通常传 `NULL`，表示使用**系统默认属性**（绝大多数情况都够用了）。

#### ③ `void *(*start_routine) (void *)` (工作内容)

* **作用：** 这是一个**函数指针**，指向线程要执行的函数。
* **要求：** 该函数必须返回 `void *` 且接受一个 `void *` 参数。
* **类比：** 这就是给员工安排的“具体任务”。一旦线程创建成功，它就会立即跳转到这个函数开始运行。

#### ④ `void *arg` (工作工具/材料)

* **作用：** 传递给 `start_routine` 函数的参数。
* **技巧：** 因为是 `void *` 类型，你可以传递任何数据的地址（整数、结构体等）。如果没有参数要传，就给 `NULL`。

---

### 2. 返回值（与普通函数不同！）

* **成功：** 返回 `0`。
* **失败：** 返回 **错误号（Error Number）**。
* **注意：** 它**不设置**全局变量 `errno`。你不能用 `perror()` 打印错误，而应该使用 `strerror(ret)`。

---

### 3. 内存布局图示

理解线程创建最直观的方法是看它如何拆分父进程的资源：

* **共享资源：** 所有线程共享代码段、全局变量、堆（Heap）。
* **私有资源：** 每个线程拥有自己独立的**栈（Stack）**空间，用于存放局部变量。

---

### 4. 代码示例

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

// 线程要执行的任务
void* task(void* arg) {
    int num = *(int*)arg;
    printf("我是子线程，收到的参数是: %d, 我的线程ID是: %lu\n", num, pthread_self());
    return NULL;
}

int main() {
    pthread_t tid;
    int data = 100;

    // 创建线程
    int ret = pthread_create(&tid, NULL, task, &data);
    if (ret != 0) {
        fprintf(stderr, "创建失败\n");
        return 1;
    }

    printf("我是主线程，创建子线程成功，其ID为: %lu\n", tid);
    
    // 主线程需要等待一下子线程，否则主线程结束，进程就没了
    sleep(1); 
    return 0;
}

```

---

### 5. 两个必须要避开的“坑”

#### A. 局部变量地址传递风险

在 `arg` 传递参数时，如果你传的是主线程栈上的局部变量地址，而主线程函数很快执行完了（或者变量作用域结束了），子线程再去访问那个地址就会产生**非法内存访问**。

* **解决方法：** 传堆内存地址（malloc）或者全局变量。

#### B. “僵尸线程”问题

和子进程一样，线程结束后也需要被回收。

* 如果不回收，线程的退出状态和栈资源会残留在内存中。
* **解决方法：** 使用 `pthread_join()` 主动等待回收，或者使用 `pthread_detach()` 让线程结束后自动释放资源。

---

### 总结

`pthread_create` 是并发编程的起点。它创建的是**用户态线程**，虽然在 Linux 底层对应一个 **LWP**，但我们在编写代码时，更多地是操作 `pthread_t`。

**你想看看如何使用 `pthread_join` 来获取子线程计算完返回的结果吗？这涉及到 `void **` 这种稍微有点绕的二级指针用法。**
