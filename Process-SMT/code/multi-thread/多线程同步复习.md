# 多线程同步：互斥量、读写锁、信号量与死锁 复习笔记

本目录下四个示例代码分别对应一种同步机制或典型问题，本文档按代码内容总结原理与用法，便于复习。

---

## 目录

- [一、本目录四个文件概览](#一本目录四个文件概览)
- [二、互斥量（Mutex）](#二互斥量mutex)
  - [2.1 原理](#21-原理) · [2.2 对应代码](#22-对应代码pthread_producer_consumerc) · [2.3 常用 API](#23-常用-api复习) · [2.4 重要函数说明](#24-重要函数说明)
- [三、读写锁（Read-Write Lock）](#三读写锁read-write-lock)
  - [3.1 原理](#31-原理) · [3.2 规则小结](#32-规则小结) · [3.3 对应代码](#33-对应代码rwlock-democ) · [3.4 常用 API](#34-常用-api复习) · [3.5 重要函数说明](#35-重要函数说明)
- [四、信号量（Semaphore）](#四信号量semaphore)
  - [4.1 原理](#41-原理) · [4.2 对应代码](#42-对应代码semaphore_producer_consumerc) · [4.3 常用 API](#43-常用-api复习) · [4.4 重要函数说明](#44-重要函数说明)
- [五、死锁（Deadlock）](#五死锁deadlock)
- [六、对比小结](#六对比小结)
- [七、本目录代码速查](#七本目录代码速查)

---

## 一、本目录四个文件概览

| 文件 | 主题 | 核心内容 |
|------|------|----------|
| **lock-self.c** | 死锁复现 | 两把锁、两线程相反加锁顺序 → 循环等待导致死锁；另含「同一线程对同一把锁重复加锁」的注释说明 |
| **pthread_producer_consumer.c** | 互斥量 + 条件变量 | 单生产者单消费者、链表队列，用 mutex 保护共享链表，用 cond 在「无产品」时阻塞消费者 |
| **rwlock-demo.c** | 读写锁 | 多读者多写者、共享缓冲区，读用 rdlock、写用 wrlock，体现「读共享、写独占」 |
| **semaphore_producer_consumer.c** | 信号量 | 单生产者多消费者、有界缓冲区（空位 8 个），用 `blank_num` / `product_num` 控制空位与产品数量，mutex 保护链表 |

---

## 二、互斥量（Mutex）

### 2.1 原理

- **互斥量**保证同一时刻只有一个线程进入临界区，即对共享资源的访问是**互斥**的。
- 线程先 `lock`，进入临界区；退出时 `unlock`。其他线程在 `lock` 时若锁已被占用则**阻塞**，直到锁被释放。

### 2.2 对应代码：`pthread_producer_consumer.c`

- **共享资源**：链表头 `mp` 及其链表（哑元头节点，`mp->next` 为第一个产品）。
- **互斥**：所有对链表的修改（头插、取头节点）都在 `pthread_mutex_lock(&mutex)` 和 `pthread_mutex_unlock(&mutex)` 之间完成。
- **条件变量**：当链表为空（`mp->next == NULL`）时，消费者在 `pthread_cond_wait(&has_product, &mutex)` 上等待；生产者放入产品后调用 `pthread_cond_signal(&has_product)` 唤醒一个消费者。
- **注意**：条件判断必须用 `while (mp->next == NULL)` 再 `wait`，避免被唤醒后条件仍不满足（虚假唤醒）。

### 2.3 常用 API（复习）

```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
// 或
pthread_mutex_init(&mutex, NULL);

pthread_mutex_lock(&mutex);     // 阻塞式加锁
pthread_mutex_trylock(&mutex);  // 非阻塞尝试加锁，成功返回 0，失败返回 EBUSY
pthread_mutex_unlock(&mutex);   // 解锁
pthread_mutex_destroy(&mutex);
```

### 2.4 重要函数说明

| 函数 | 说明 |
|------|------|
| `int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)` | 动态初始化互斥量。`attr` 常为 `NULL`。成功返回 0，失败返回错误码。 |
| `int pthread_mutex_lock(pthread_mutex_t *mutex)` | 加锁；若已被占用则**阻塞**直到获得锁。成功返回 0。 |
| `int pthread_mutex_trylock(pthread_mutex_t *mutex)` | **尝试**加锁，不阻塞。成功返回 0；若锁正被占用返回 `EBUSY`。可用于避免死锁（拿不到就先做别的事或释放已持锁再重试）。 |
| `int pthread_mutex_unlock(pthread_mutex_t *mutex)` | 解锁。必须由当前持有该锁的线程调用。成功返回 0。 |
| `int pthread_mutex_destroy(pthread_mutex_t *mutex)` | 销毁互斥量。调用时锁应处于未锁定状态。 |
| `int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)` | 在条件变量上等待。**原子地**释放 `mutex` 并阻塞；被唤醒后重新获取 `mutex` 再返回。调用前必须已持有 `mutex`。 |
| `int pthread_cond_signal(pthread_cond_t *cond)` | 唤醒在该条件变量上等待的**至少一个**线程。 |

---

## 三、读写锁（Read-Write Lock）

### 3.1 原理

- **读锁（共享锁）**：多个线程可以同时持有读锁，用于**只读**访问。
- **写锁（独占锁）**：同一时刻只能有一个线程持有写锁，且持有写锁时不能有读锁或其他写锁。
- 适用场景：**读多写少**，希望多读者并发、写者独占，提高读并发度。

### 3.2 规则小结

| 当前状态   | 再申请读锁 | 再申请写锁 |
|------------|------------|------------|
| 无锁       | 允许       | 允许       |
| 已有读锁   | 允许       | 阻塞       |
| 已有写锁   | 阻塞       | 阻塞       |

### 3.3 对应代码：`rwlock-demo.c`

- **共享资源**：`shared_buffer`、`shared_version`。
- **读者**：`pthread_rwlock_rdlock` → 读缓冲区与版本号 → `pthread_rwlock_unlock`，多个读者可同时执行。
- **写者**：`pthread_rwlock_wrlock` → 更新缓冲区和版本号 → `pthread_rwlock_unlock`，写时独占。
- 同一把锁用同一个 `unlock`，无需区分读/写。

### 3.4 常用 API（复习）

```c
pthread_rwlock_t rwlock;
pthread_rwlock_init(&rwlock, NULL);

pthread_rwlock_rdlock(&rwlock);   // 读锁（阻塞）
pthread_rwlock_tryrdlock(&rwlock); // 尝试读锁，不阻塞，失败返回 EBUSY
pthread_rwlock_wrlock(&rwlock);   // 写锁（阻塞）
pthread_rwlock_trywrlock(&rwlock); // 尝试写锁，不阻塞，失败返回 EBUSY
pthread_rwlock_unlock(&rwlock);
pthread_rwlock_destroy(&rwlock);
```

### 3.5 重要函数说明

| 函数 | 说明 |
|------|------|
| `int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr)` | 初始化读写锁。`attr` 常为 `NULL`。成功返回 0。 |
| `int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)` | 加**读锁**；若已有写锁或策略上需等待写者则阻塞。成功返回 0。 |
| `int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)` | **尝试**加读锁，不阻塞。成功返回 0；无法立即获得时返回 `EBUSY` 等。 |
| `int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)` | 加**写锁**；若已有读锁或写锁则阻塞。成功返回 0。 |
| `int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)` | **尝试**加写锁，不阻塞。成功返回 0；无法立即获得时返回 `EBUSY` 等。 |
| `int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)` | 释放当前线程持有的读锁或写锁（同一把锁统一用此接口）。成功返回 0。 |
| `int pthread_rwlock_destroy(pthread_rwlock_t *rwlock)` | 销毁读写锁。调用时锁应未被任何线程持有且无等待者。 |

---

## 四、信号量（Semaphore）

### 4.1 原理

- 信号量是一个**非负整数计数器**，表示「可用资源数量」或「可执行操作的许可数」。
- **P 操作（wait）**：`sem_wait`，若值 > 0 则减 1 并返回；若为 0 则阻塞直到能减 1。
- **V 操作（post）**：`sem_post`，将值加 1，若有线程在 wait 则唤醒一个。
- 与互斥量区别：互斥量只有 0/1，且通常由「加锁者」解锁；信号量可以有多份资源，且 P/V 可由不同线程执行（典型用于生产者-消费者中的「空位」与「产品数」）。

### 4.2 对应代码：`semaphore_producer_consumer.c`

- **product_num**：当前产品数量，初值为 0。消费者先 `sem_wait(&product_num)` 再取产品，生产者放完产品后 `sem_post(&product_num)`。
- **blank_num**：空位数量，初值为 8（有界缓冲区最多 8 个节点）。生产者先 `sem_wait(&blank_num)` 再插入，消费者取走后 `sem_post(&blank_num)`。
- **互斥**：对链表指针的修改仍用 `pthread_mutex_t mutex` 保护，避免多消费者/生产者同时改链表导致数据竞争。信号量只负责「数量」与「阻塞/唤醒」，不负责「互斥修改链表结构」。

### 4.3 常用 API（复习）

```c
sem_t product_num, blank_num;
sem_init(&product_num, 0, 0);   // 0 表示线程间共享，初值 0
sem_init(&blank_num,  0, 8);   // 初值 8 表示 8 个空位

sem_wait(&product_num);   // P：产品数 -1，若为 0 则阻塞
sem_trywait(&product_num); // 非阻塞 P：能减则减并返回 0，否则返回 -1 且 errno 为 EAGAIN
sem_post(&product_num);   // V：产品数 +1，可能唤醒等待者

sem_destroy(&product_num); // 应在所有线程 join 之后再 destroy
```

### 4.4 重要函数说明

| 函数 | 说明 |
|------|------|
| `int sem_init(sem_t *sem, int pshared, unsigned int value)` | 初始化信号量。`pshared` 为 0 表示同一进程内线程共享；`value` 为初值。成功返回 0，失败返回 -1 并设置 errno。 |
| `int sem_wait(sem_t *sem)` | **P 操作**：若值 > 0 则减 1 并返回；若为 0 则**阻塞**直到可减 1。成功返回 0。 |
| `int sem_trywait(sem_t *sem)` | **非阻塞 P**：若值 > 0 则减 1 并返回 0；若为 0 则立即返回 -1，并设置 `errno = EAGAIN`。 |
| `int sem_post(sem_t *sem)` | **V 操作**：值加 1；若有线程在 `sem_wait` 上阻塞则唤醒至少一个。成功返回 0。 |
| `int sem_destroy(sem_t *sem)` | 销毁信号量。应在没有线程正在 wait 且不再使用该信号量后调用。 |

---

## 五、死锁（Deadlock）

### 5.1 原理

**死锁**指一组线程各自持有部分资源，并等待对方释放资源，形成**循环等待**，导致都无法继续执行。

常见两种情形（对应 `lock-self.c` 注释）：

1. **同一线程对同一把锁重复加锁**：若 mutex 非「递归锁」，第二次 `lock` 会阻塞，而能解锁的只有当前线程 → 自己等自己，死锁。
2. **两线程、两把锁，加锁顺序相反**：  
   - 线程 A：先拿 mutex1，再拿 mutex2。  
   - 线程 B：先拿 mutex2，再拿 mutex1。  
   - 若某一时刻 A 持有 mutex1、B 持有 mutex2，则 A 等 mutex2、B 等 mutex1 → 循环等待，死锁。

### 5.2 对应代码：`lock-self.c`

- **死锁复现**：主线程循环里先 `lock(mutex2)` 再 `lock(mutex1)`；子线程 `tfn2` 先 `lock(mutex1)` 再 `lock(mutex2)`。两者顺序相反，运行一段时间后容易形成「主线程持 mutex2 等 mutex1，子线程持 mutex1 等 mutex2」的死锁。
- **自加锁（未在运行逻辑中启用）**：`tfn1` 对 `mutex` 加锁后直接 `pthread_exit`，没有解锁，用于理解「同一把锁重复加锁」会死锁（若在 tfn1 里再 lock 一次则会自死锁）。

### 5.3 避免死锁的常见做法

- **全局加锁顺序**：所有线程对多把锁都按同一顺序加锁（例如先 mutex1 再 mutex2），避免循环等待。
- **尽量缩短持锁时间**、减少嵌套锁。
- 使用 **trylock**：拿不到就释放已持有的锁并重试，避免一直等。
- 使用**递归锁**（仅针对「同一线程重复加锁」场景，需按需使用）。

---

## 六、对比小结

| 机制       | 作用               | 典型用途                     |
|------------|--------------------|------------------------------|
| **互斥量** | 临界区互斥，同一时刻一人进入 | 保护任意共享数据结构         |
| **条件变量** | 在「条件不满足」时阻塞，被唤醒后重新检查 | 与 mutex 配合，实现「等条件成立」 |
| **读写锁** | 多读共享、写独占   | 读多写少的共享数据           |
| **信号量** | 资源计数、P/V 阻塞/唤醒 | 有界缓冲区、多份资源、生产者-消费者 |
| **死锁**   | 需避免的问题       | 固定加锁顺序、少嵌套、trylock 等 |

---

## 七、本目录代码速查

- **互斥量 + 条件变量**：`pthread_producer_consumer.c` — mutex 保护链表，cond 表示「有产品」。
- **读写锁**：`rwlock-demo.c` — rdlock/wrlock 区分读者与写者。
- **信号量**：`semaphore_producer_consumer.c` — `blank_num` / `product_num` 控制空位与产品数，mutex 保护链表。
- **死锁**：`lock-self.c` — 两锁、两线程相反加锁顺序导致循环等待。

按「互斥量 → 读写锁 → 信号量 → 死锁」顺序结合代码复习，即可覆盖本目录涉及的多线程同步核心知识。
